title: JVM中内存管理
date: 2017-8-6
tags:
- Java
- JVM
- 内存管理
- 垃圾回收
- gc
----

## 引

Java语言和C/C++相比，内存管理上具有一个很明显的特征：具有自动垃圾回收机制。C/C++程序员在动态申请内存上需要很小心，使用完毕后必须手动的释放申请的内存，否则很容易出现内存泄漏（memory leak）问题。

Java程序员是否就可以高枕无忧了呢？如果不了解JVM内存回收机制，在实际出现OOM异常（out-of-memory）时，调错调优也是会一头雾水。所以，了解JVM内存管理机制很有必要，下面将逐一介绍JVM中的运行时数据区，JVM回收算法、回收策略。

## JVM运行时数据区


<img alt="jvm-runtime-data-areas" src="http://javapapers.com/wp-content/uploads/2013/11/JVM-Run-time-Data-Areas.png" />

上图是我直接在网上找的图，可以看出JVM运行时数据区包括如下几个部分：
- 全部线程共享：
    - 堆（Heap）
    - 方法区
- 各个线程独享：
    - 栈 (JVM stacks)
    - 本地方法栈（native method stacks)
    - PC寄存器 (pc)

下表是这几个区域的比较：

名称 | 存放内容 | 是否线程共享 | 是否垃圾回收 | 大小如何配置
---|------|--------|--------|-------
堆 | 数组和类实例数据 | ✔️ | ✔️ | -Xms120m -Xmx120m, 配置最大最小堆内存大小为120M
方法区 | 又称为“非堆”内存，class对象、方法对象，虚拟机已经加载的类信息、常量、静态变量等；运行时常量池也属于方法区 | ✔️ | ✔️  | -XX:PermSize=64M -XX:MaxPermSize=256M, HotSpot虚拟机中，没有专门的方法区，但是有堆“永久代”
栈 | 保存本地变量，操作数堆栈，对运行时常量池的引用 | ❌ | ❌ |-Xss1M, 每个线程堆栈默认大小是1M
本地方法栈 | 与栈非常类似，只不过是为了调用本地方法服务 | ❌ | ❌ | - 
PC寄存器 | 指向线程下一条指令的地址 | ❌ | ❌ | - 

## 对象的创建和内存布局

### 对象创建过程

这里只讨论普通对象（非数组对象和Class对象）的创建过程：
- 首先判断对象对应的类有没有加载，否则执行类加载过程；
- 为对象分配内存（因为一个对象需要的内存可以由类类型确定）：
    - 使用指针碰撞（Bump the pointer），由一个指针指向当前分配的内存，需要分配新内存时，向另一端移动。因为对象分配内存的操作是非常频繁的，因此指针移动操作需要同步机制；
    - 使用空闲列表（Free List），有一个列表记录了当前连续空间大小，当需要分配内存时，直接查询列表哪一项可以满足需求。不足的地方是会产生内存碎片。
    - 具体使用哪种分配算法根据垃圾收集器是否带有整理功能（compact), `Serial\ParSerial`等带有compact功能的收集器是使用指针碰撞，`CMS`则是空闲列表
- 为对象实例数据赋空值
- 设置对象头信息
- 执行`<init>`方法，是用程序初始化对象数据

### 对象内存布局和访问

![对象访问](https://raw.githubusercontent.com/lxyangfan/lxyangfan.github.io/hexo/source/uploads/jvm.jpg)

## JVM内存回收

- 哪些内存需要回收?
    栈是线程独享，在线程执行完毕时可以被销毁，大小和回收时间确定；	 对象和数组分配在堆上，被线程共享，大小和存活时间运行时才能确定，需要对这块内存回收管理。
- 何时回收?
    对象不再需要的时候，需要回收它所占的内存。

- 如何回收
    垃圾回收算法（垃圾收集器实现）

### 对象已“死”吗？

判断对象是否存活的方法：
- 引用计数法：

被引用一次，计数加一，引用结束，计数减一，计数为负数，标记为需要被回收；（优势：简单，好实现，Python使用本方法回收内存；不足：无法解决循环引用的问题）

- 可达性分析

![可达性分析](https://raw.githubusercontent.com/lxyangfan/lxyangfan.github.io/hexo/source/uploads/gc-roots.jpg)

### 强软弱虚引用

- 强引用
     代码中普遍存在的，如 “Object a = new XX();”这样的引用，只要强引用还存在，对象就不会被回收；

- 软引用 SoftReference
     比强引用稍弱，在发生OOM异常之前，弱引用的对象才会列入二次回收的范围。如果二次回收之后，还是内存不够，才会报OOM异常；

- 弱引用 WeakReference
     比软引用还弱，弱引用的对象只会生存到下一次GC来临之前；无论内存是否够用，弱引用的对象分配的内存都会被回收；

- 虚引用 PhantomReference
     最弱的引用，虚引用是否存在完全不会对对象生存时间有影响，也无法从虚引用取得对象实例。仅被设计为在GC时获取通知


## 引用

本文是对《深入理解JAVA虚拟机》一书的读书笔记，不足和疏漏之处需要查看原书。

[JVM系列三:JVM参数设置、分析](http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html)




