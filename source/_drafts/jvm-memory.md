title: JVM中内存管理
date: 2017-8-6
tags:
- Java
- JVM
- 内存管理
- 垃圾回收
- gc
----

## 引

Java语言和C/C++相比，内存管理上具有一个很明显的特征：具有自动垃圾回收机制。C/C++程序员在动态申请内存上需要很小心，使用完毕后必须手动的释放申请的内存，否则很容易出现内存泄漏（memory leak）问题。

Java程序员是否就可以高枕无忧了呢？如果不了解JVM内存回收机制，在实际出现OOM异常（out-of-memory）时，调错调优也是会一头雾水。所以，了解JVM内存管理机制很有必要，下面将逐一介绍JVM中的运行时数据区，JVM回收算法、回收策略。

## JVM运行时数据区


<img alt="jvm-runtime-data-areas" src="http://javapapers.com/wp-content/uploads/2013/11/JVM-Run-time-Data-Areas.png" />

上图是我直接在网上找的图，可以看出JVM运行时数据区包括如下几个部分：
- 全部线程共享：
    - 堆（Heap）
    - 方法区
- 各个线程独享：
    - 栈 (JVM stacks)
    - 本地方法栈（native method stacks)
    - PC寄存器 (pc)

下表是这几个区域的比较：

名称 | 存放内容 | 是否线程共享 | 是否垃圾回收 | 大小如何配置
---|------|--------|--------|-------
堆 | 数组和类实例数据 | ✔️ | ✔️ | -Xms120m -Xmx120m, 配置最大最小堆内存大小为120M
方法区 | 又称为“非堆”内存，class对象、方法对象，虚拟机已经加载的类信息、常量、静态变量等；运行时常量池也属于方法区 | ✔️ | ✔️  | -XX:PermSize=64M -XX:MaxPermSize=256M, HotSpot虚拟机中，没有专门的方法区，但是有堆“永久代”
栈 | 保存本地变量，操作数堆栈，对运行时常量池的引用 | ❌ | ❌ |-Xss1M, 每个线程堆栈默认大小是1M
本地方法栈 | 与栈非常类似，只不过是为了调用本地方法服务 | ❌ | ❌ | - 
PC寄存器 | 指向线程下一条指令的地址 | ❌ | ❌ | - 

## 对象的创建和内存布局

### 对象创建过程

这里只讨论普通对象（非数组对象和Class对象）的创建过程：
- 首先判断对象对应的类有没有加载，否则执行类加载过程；
- 为对象分配内存（因为一个对象需要的内存可以由类类型确定）：
    - 使用指针碰撞（Bump the pointer），由一个指针指向当前分配的内存，需要分配新内存时，向另一端移动。因为对象分配内存的操作是非常频繁的，因此指针移动操作需要同步机制；
    - 使用空闲列表（Free List），有一个列表记录了当前连续空间大小，当需要分配内存时，直接查询列表哪一项可以满足需求。不足的地方是会产生内存碎片。
    - 具体使用哪种分配算法根据垃圾收集器是否带有整理功能（compact), `Serial\ParSerial`等带有compact功能的收集器是使用指针碰撞，`CMS`则是空闲列表
- 为对象实例数据赋空值
- 设置对象头信息
- 执行`<init>`方法，是用程序初始化对象数据

### 对象内存布局和访问

![对象访问](http://)

## JVM内存回收

- 哪些内存需要回收
- 何时回收
- 如何回收

## 引用

本文是对《深入理解JAVA虚拟机》一书的读书笔记，不足和疏漏之处需要查看原书。

[JVM系列三:JVM参数设置、分析](http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html)




